# 配置`Windbg`符号表

参考文档[Windows 调试器的符号路径 - Windows drivers | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows-hardware/drivers/debugger/symbol-path)

![image-20230330152615845](images\image-20230330152615845.png)

先使用本地符号文件,如果没有会自动去微软官网下载

```powershell
srv*D:\symbols*http://msdl.microsoft.com/download/symbols
```



# `Windbg`常用命令

一般扩展命令前面带感叹号,不带感叹号的是`windbg`基本命令

查看帮助文档

```powershell
.hh
```

查看`sos.dll`扩展命令

```powershell
!sos.help
```

查询`sos.dl`l某个指令的具体帮助文档

```powershell
!sos.help DumpObj
```

清屏命令

```powershell
.cls
```

清除所有断点

```powershell
bc *
```

观察对象实例,`!do`只能观察一个层级，`!mdt`可多个层级

```
!mdt
```

托管版的搜索元数据`sosex`扩展

```
!mx Example_9_1!*Person*
```

死锁检测

```
!dlk
```



## `SOS`扩展命令

`WinDbg  Preview`会自动加载`sos.dll`，如果是其他版本的`WinDbg`需要手动加载对饮高版本的`sos.dll`

```powershell
.load C:\Windows\Microsoft.NET\Framework\v4.0.30319\SOS.dll
```

```powershell
.loadby sos.dll clrjit
```

使用`.loadby` 命令很容易的就可以加载SOS扩展，而不需要自己去判断当前程序是.NET什么版本的。

### 查看某个类型的堆栈

```powershell
!dumpheap -type Person
```

![image-20230330092614053](images\image-20230330092614053.png)

### 根据对象地址查看对象内容

完整命令

```powershell
!DumpObj /d 02af2480
```

简写命令

```powershell
!do 02af2480
```

![image-20230330095602954](images\image-20230330095602954.png)

### 从内存的角度查看对象信息

参数`l4`是指显示4个指针长度的内存地址,减去4个字节是因为要将同步块索引也打印出来

```powershell
dp 02af2480-0x4 l4
```

![image-20230330101636128](images\image-20230330101636128.png)

![image-20230330101828742](images\image-20230330101828742.png)

### 在内存中打印出person对象

```powershell
dp 02af2468-0x4
```

![image-20230330110240323](images\image-20230330110240323.png)

使用`du`命令查看字符串的内容

```powershell
du 02af2468+0x8
```

![image-20230330110658705](images\image-20230330110658705.png)

### 基本调试命令

![image-20230330150727730](images\image-20230330150727730.png)

![image-20230330150824170](images\image-20230330150824170.png)

### 退出调试

![image-20230330151120977](images\image-20230330151120977.png)

## 对代码下断点

### 对非托管函数下断点

#### 对记事本的保存方法下断点

使用以下命令查找记事本的保存方法

注:`win11`记事本用以下命令无法找到,需要`windbg`在文件`C:\Windows\System32`下选择可执行程序`notepad.exe`

```powershell
x notepad!*Savefile*
```

下断点可以用方法名或内存地址，以下两种方式都可以

```
bp notepad!SaveFile
```

```
bp 00007ff7`4d671d88
```

![image-20230330162052000](images\image-20230330162052000.png)

之后对记事本操作保存即可命中断点

![image-20230330162236704](images\image-20230330162236704.png)

### 对托管函数下断点

#### 对被`Jit`编译过的函数下断点与非托管的一致

#### 对未被`Jit`编译过的函数进行断点设置

使用`name2ee`命令可以查询方法是否被`Jit`编译过

```powershell
!name2ee Example_02!Example_02.Program.Sum
```

![image-20230330182945243](images\image-20230330182945243.png)

##### 使用sos扩展

使用`bpmd`命令进行断点设置,`jit`编译方法后会给调试器一个通知,调试器会自动设置断点

```powershell
!bpmd Example_02.exe Example_02.Program.Sum
```

![image-20230330183421829](images\image-20230330183421829.png)

##### 使用sosex扩展

加载`sosex.dll`(根据程序判断,只支持`.netframework`)

```powershell
.load D:\Sosex\sosex_32\sosex.dll
```

使用`mbm`命令下断点

```powershell
!mbm Example_02!Example_02.Program.Sum
```

![image-20230330213933402](images\image-20230330213933402.png)

使用`mbm`命令可模糊匹配

```powershell
!mbm Example_02*.Sum
```

![image-20230330214554960](images\image-20230330214554960.png)

##### 对泛型方法下断点

使用`dumpdomain`命令找出具体模块

```
!dumpdomain
```

![image-20230330223205829](images\image-20230330223205829.png)

使用`dumpmodule` 命令找出模块中的类名

```powershell
!dumpmodule -mt 01214044
```

使用`dumpmt`命令打印出泛型类名的方法

```powershell
!dumpmt -md 01214de4
```

![image-20230330224135699](images\image-20230330224135699.png)

最后再用`bpmd`或者`mbm`命令下断点

```powershell
!bpmd Example_03.exe Example_03.MyList`1.Add
```

![image-20230330224801422](images\image-20230330224801422.png)

```powershell
!mbm Example_03!Example_03.MyList`1.Add
```

![image-20230330225502788](images\image-20230330225502788.png)

##### 根据某个文件的代码行数下断点

- 使用`sosex.dll`的`mbp`扩展命令

  ```powershell
  !mbp Program.cs 18
  ```

  该命令对代码的第18行下断点,执行后会命中断点

  ![image-20230331161003432](images\image-20230331161003432.png)

## 分析32位程序在64位程序导出的`DUMP`文件

### 切换成32位模式

```
.load wow64exts
```

```
!sw
```

